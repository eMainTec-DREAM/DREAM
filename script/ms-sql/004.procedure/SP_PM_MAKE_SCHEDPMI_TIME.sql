CREATE PROCEDURE [dbo].[SP_PM_MAKE_SCHEDPMI_TIME](     @v_comp_no     varchar(6)     ,@v_pm_id       bigint     ,@v_target_date varchar(8)) as    	SET NOCOUNT ON;	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;	declare @v_count                         numeric(4); 	declare @v_del_start_date      varchar(8);    declare @v_last_sch_date       varchar(8);	declare @v_next_sch_date       varchar(8);    declare @v_to_day              varchar(8);        DECLARE c_SP_PM_MAKE_SCHEDPMI_TIME CURSOR FOR            SELECT                 A.pm_id                ,A.CYCLE                ,A.period_type                 ,b.last_sch_date    -- 다음일정 예정일[주말보정전]                ,b.equip_id				,A.wrkcallist_id				,B.PMEQUIP_ID            FROM TAPMLST A, TAPMEQUIP B            WHERE 1=1                AND A.COMP_NO = B.COMP_NO                AND A.PM_ID = B.PM_ID                AND A.comp_no = @v_comp_no                AND A.pm_id     = @v_pm_id                AND A.is_active = 'Y'                AND B.last_sch_date <= @v_target_date        ;		set @v_to_day = CONVERT(varchar(8), getdate(), 112)		DECLARE  @pm_id bigint            ,@CYCLE numeric(4)            ,@period_type  varchar(20)            ,@last_sch_date varchar(8)            ,@equip_id  bigint            ,@wrkcallist_id  bigint			,@PMEQUIP_ID  bigint		OPEN c_SP_PM_MAKE_SCHEDPMI_TIME		FETCH NEXT FROM c_SP_PM_MAKE_SCHEDPMI_TIME INTO @pm_id,@CYCLE,@period_type,@last_sch_date,@equip_id,@wrkcallist_id,@PMEQUIP_ID		WHILE (@@FETCH_STATUS=0)			BEGIN			    -- 스케쥴을 시작하기로 한 날짜 이후에 점검결과가 완료되었는지 확인.                -- 발행된건이 있으면 그 건의 날짜를 시작날짜로 지정하여 스케쥴을 생성함.                SELECT @v_count = COUNT(*)                FROM TAPMINSSCHED                WHERE comp_no = @v_comp_no                    AND pm_id = @pm_id                     AND pmequip_id = @pmequip_id                    AND pmsched_status IN ('C') -- work order가 완료되었는지 확인.                    AND plan_init_date >= @last_sch_date  -- 스케쥴을 시작하기로 한 날짜 이후에 점검결과가 완료되었는지 확인.                ;                                IF @v_count > 0				    begin                        -- 오늘부터 스케쥴시작 날짜 이전까지의  완료되지 않는 스케쥴,설비,점검결과를 삭제해야 함.                         SELECT @v_last_sch_date = isnull(MAX(plan_init_date),@last_sch_date)                        FROM TAPMINSSCHED                        WHERE comp_no = @v_comp_no                            AND pm_id = @pm_id                             AND pmequip_id = @pmequip_id                            AND pmsched_status IN ('C') -- work order가 완료된 상태                            AND plan_init_date >= @last_sch_date                        ;                                                -- 스케쥴 시작할 날짜가 오늘보다 큰지 비교해서 기존에 생성된 작업중에 완료안된 작업을 삭제함.                        -- 미 작업이라고 하더라도 오늘일자 이후에 데이타만 삭제함. 오늘이전 데이타는 삭제하지 않음.                        -----------------------------------------------------------------------------------------------------------------------------------------------                        if @v_to_day > @v_last_sch_date                            set @v_del_start_date = @v_to_day;                        else                            set @v_del_start_date = @v_last_sch_date;                        -- 작업이 완료되지 않은 점검설비를 삭제함.                         exec SP_PM_MAKE_SCHEDPMI_DELETE @v_comp_no , @pm_id, @pmequip_id, @v_del_start_date;                       -----------------------------------------------------------------------------------------------------------------------------------------------                                              -- 예방작업을 완료한 최종일자를 확인했으므로 그 다음 일정을 언제 생성해야 할지를 알아냄.                       SELECT @v_last_sch_date =                                 CASE 									WHEN @period_type = 'D' THEN CONVERT(VARCHAR(8), DATEADD(DAY,(@cycle * 1 ),CAST(@v_last_sch_date AS DATETIME)), 112)									WHEN @period_type = 'W' THEN CONVERT(VARCHAR(8), DATEADD(DAY,(@cycle * 7 ),CAST(@v_last_sch_date AS DATETIME)), 112)									WHEN @period_type = 'M' THEN CONVERT(VARCHAR(8), DATEADD(MONTH,(@cycle * 1 ),CAST(@v_last_sch_date AS DATETIME)), 112)									WHEN @period_type = 'Y' THEN CONVERT(VARCHAR(8), DATEADD(MONTH,(@cycle * 12 ),CAST(@v_last_sch_date AS DATETIME)), 112)							END                        ;					end                ELSE 				   begin                        -- 사용자가 입력한 날짜를 작업일정의 시작으로 결정함.                        set @v_last_sch_date = @last_sch_date;                                              -- 미 작업이라고 하더라도 오늘일자 이후에 데이타만 삭제함. 오늘이전 데이타는 삭제하지 않음.                         if @v_to_day > @v_last_sch_date                            set @v_del_start_date = @v_to_day;                        else                            set @v_del_start_date = @v_last_sch_date;                                                -- 작업이 완료되지 않은 오더를 삭제함. 오더에 상태가 결재중이거나, 취소이거나 하면 어떻게 처리해야 할지 추가로 결정해야 함.                        exec SP_PM_MAKE_SCHEDPMI_DELETE @v_comp_no , @pm_id, @pmequip_id, @v_del_start_date;				   end                                       -- 여기서 부터는 예방작업 일정을 만드는 작업을 수행함.                -- 먼저 예방작업을 언제 만들지를 갱신하고 시작업..v_last_sch_date는 이 날짜 부터 일정을 생성해야 한다는 의미임.                UPDATE TAPMEQUIP SET                       last_sch_date = @v_last_sch_date                      ,next_sch_date = @v_last_sch_date                WHERE comp_no = @v_comp_no                      AND pm_id = @pm_id                      AND pmequip_id = @pmequip_id                ;                                                 --  v_target_date까지 예방작업일정을 생성함.                WHILE @v_last_sch_date <= @v_target_date				   begin                                                -- v_last_sch_date 는 이 날짜에 일정을 생성해야 하는 일자인데 이 날짜가 근무일이 아니면 근무일을 찾아서 보정해 줘야 함.                        -- v_last_sch_date 이 작업을 만들어야 하는 일자. cycle,period_type을 체크해서 이 과거 범위한에 최대한 근접한 근무일자에 작업을 만들어 줌.                            SELECT @v_next_sch_date =  isnull(max(cal_date), '19000101')                            FROM TAWRKCALENDAR A                            WHERE A.comp_no = @v_comp_no                                AND a.wrkcallist_id = @wrkcallist_id                                AND A.cal_date <=@v_last_sch_date                                and a.cal_date >  (CASE 														WHEN @period_type = 'D' THEN CONVERT(VARCHAR(8), DATEADD(DAY,(@cycle * -1 ),CAST(@v_last_sch_date AS DATETIME)), 112)														WHEN @period_type = 'W' THEN CONVERT(VARCHAR(8), DATEADD(DAY,(@cycle * -7 ),CAST(@v_last_sch_date AS DATETIME)), 112)														WHEN @period_type = 'M' THEN CONVERT(VARCHAR(8), DATEADD(MONTH,(1 * -1 ),CAST(@v_last_sch_date AS DATETIME)), 112)  --한달로 제한														WHEN @period_type = 'Y' THEN CONVERT(VARCHAR(8), DATEADD(MONTH,(1 * -1 ),CAST(@v_last_sch_date AS DATETIME)), 112)  -- 한달로 제한												END )                                AND A.is_work = 'Y'                            ;                            							IF @v_next_sch_date != '19000101'								begin								-- 단 그 근무일에 과거이면 생성하지 않고 오늘이후 조건시에만 생성해야 함.								IF @v_next_sch_date > @v_to_day									INSERT INTO TAPMINSSCHED(comp_no, pminssched_id, pmequip_id, equip_id,  pm_id, plan_init_date, plan_date,sched_date, pmsched_status)									values( @v_comp_no,NEXT VALUE FOR sqapminssched_id, @pmequip_id, @equip_id, @pm_id, @v_last_sch_date, @v_next_sch_date, @v_next_sch_date,'P' );                                end;							ELSE								-- 19000101이면 근무일이 없다는 얘기이므로 상황이 복잡하기 때문에 경우에 따라서 다른 논리를 적용함.                                -- 1. 일상점검이 아닌경우 휴일이라고 하더라도 일정을 생성함.                                                                -- 2. 일상점검을 일정을 생성하지 않음.(일상점검의 기준: cycle < 7, period_type=D)								begin									set @v_next_sch_date = @v_last_sch_date									IF @v_next_sch_date > @v_to_day and @period_type != 'D'										INSERT INTO TAPMINSSCHED(comp_no, pminssched_id, pmequip_id, equip_id,  pm_id, plan_init_date, plan_date,sched_date, pmsched_status)										values( @v_comp_no,NEXT VALUE FOR sqapminssched_id, @pmequip_id, @equip_id, @pm_id, @v_last_sch_date, @v_next_sch_date, @v_next_sch_date,'P' );																	end								;                            UPDATE TAPMEQUIP SET                                       last_sch_date = @v_last_sch_date   -- 휴일 보전전 일정, 이 일정으로 다음 작업을 생성해야 함                                      ,next_sch_date = @v_next_sch_date  -- 휴일을 보정하고 난 실제 작업일정.                            WHERE comp_no = @v_comp_no                                AND pm_id = @pm_id                                AND pmequip_id = @pmequip_id                            ;                                                         -- 다음에는 언제 일정을 생성해야할지 찾기.                         SELECT @v_last_sch_date =                                CASE                                 WHEN @period_type = 'D' THEN CONVERT(VARCHAR(8), DATEADD(DAY,(@cycle * 1 ),CAST(@v_last_sch_date AS DATETIME)), 112)								WHEN @period_type = 'W' THEN CONVERT(VARCHAR(8), DATEADD(DAY,(@cycle * 7 ),CAST(@v_last_sch_date AS DATETIME)), 112)								WHEN @period_type = 'M' THEN CONVERT(VARCHAR(8), DATEADD(MONTH,(@cycle * 1 ),CAST(@v_last_sch_date AS DATETIME)), 112)								WHEN @period_type = 'Y' THEN CONVERT(VARCHAR(8), DATEADD(MONTH,(@cycle * 12 ),CAST(@v_last_sch_date AS DATETIME)), 112)                            END                        ;                                            end			FETCH NEXT FROM c_SP_PM_MAKE_SCHEDPMI_TIME INTO @pm_id,@CYCLE,@period_type,@last_sch_date,@equip_id,@wrkcallist_id,@PMEQUIP_ID		    END		CLOSE c_SP_PM_MAKE_SCHEDPMI_TIME		DEALLOCATE c_SP_PM_MAKE_SCHEDPMI_TIME	        ;